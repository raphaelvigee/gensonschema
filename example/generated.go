// Code generated by github.com/raphaelvigee/gensonschema. DO NOT EDIT!
package gen

import (
	"encoding/json"
	"fmt"

	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

func pathJoin(p1, p2 string) string {
	if p1 == "" {
		return p2
	}

	return p1 + "." + p2
}

type AllOf struct {
	_path string
	_json *[]byte
}

func (r *AllOf) GetBilling_address() *DefinitionsAddress {
	r.ensureJson()
	return &DefinitionsAddress{
		_path: pathJoin(r._path, "billing_address"),
		_json: r._json,
	}
}

func (r *AllOf) GetShipping_address() *ShippingAddress {
	r.ensureJson()
	return &ShippingAddress{
		_path: pathJoin(r._path, "shipping_address"),
		_json: r._json,
	}
}

func (r AllOf) Set(v AllOf) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllOf) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *AllOf) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllOf{_json: &bcopy}
	return nil
}
func (r AllOf) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r AllOf) path() string {
	return r._path
}
func (r AllOf) setJson(v []byte) {
	*r._json = v
}
func (r *AllOf) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllOf) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllOf) Exists() bool {
	return r.result().Exists()
}
func (r AllOf) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type ArraysSchema struct {
	_path string
	_json *[]byte
}

func (r *ArraysSchema) GetFruits() *Fruits {
	r.ensureJson()
	return &Fruits{
		_path: pathJoin(r._path, "fruits"),
		_json: r._json,
	}
}

func (r *ArraysSchema) GetVegetables() *Vegetables {
	r.ensureJson()
	return &Vegetables{
		_path: pathJoin(r._path, "vegetables"),
		_json: r._json,
	}
}

func (r ArraysSchema) Set(v ArraysSchema) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r ArraysSchema) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *ArraysSchema) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = ArraysSchema{_json: &bcopy}
	return nil
}
func (r ArraysSchema) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r ArraysSchema) path() string {
	return r._path
}
func (r ArraysSchema) setJson(v []byte) {
	*r._json = v
}
func (r *ArraysSchema) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r ArraysSchema) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r ArraysSchema) Exists() bool {
	return r.result().Exists()
}
func (r ArraysSchema) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Bool struct {
	_path string
	_json *[]byte
}

func (r Bool) Value() bool {
	res := r.result()
	var v bool
	_ = json.Unmarshal([]byte(res.Raw), &v)
	return v
}

func (r *Bool) Set(v bool) error {
	r.ensureJson()
	if r._path == "" {
		b, err := json.Marshal(v)
		if err != nil {
			return err
		}
		r.setJson(b)
		return nil
	}
	res, err := sjson.SetBytes(r.json(), r.path(), v)
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Bool) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *Bool) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Bool{_json: &bcopy}
	return nil
}
func (r Bool) json() []byte {
	if r._json == nil {
		return []byte("false")
	}

	return *r._json
}
func (r Bool) path() string {
	return r._path
}
func (r Bool) setJson(v []byte) {
	*r._json = v
}
func (r *Bool) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Bool) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Bool) Exists() bool {
	return r.result().Exists()
}
func (r Bool) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type DefinitionsAddress struct {
	_path string
	_json *[]byte
}

func (r *DefinitionsAddress) GetCity() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "city"),
		_json: r._json,
	}
}

func (r DefinitionsAddress) Set(v DefinitionsAddress) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r DefinitionsAddress) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *DefinitionsAddress) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = DefinitionsAddress{_json: &bcopy}
	return nil
}
func (r DefinitionsAddress) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r DefinitionsAddress) path() string {
	return r._path
}
func (r DefinitionsAddress) setJson(v []byte) {
	*r._json = v
}
func (r *DefinitionsAddress) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r DefinitionsAddress) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r DefinitionsAddress) Exists() bool {
	return r.result().Exists()
}
func (r DefinitionsAddress) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Fruits struct {
	_path string
	_json *[]byte
}

func (r *Fruits) At(i int) *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, fmt.Sprint(i)),
		_json: r._json,
	}
}

func (r Fruits) Len() int {
	res := r.result()
	if !res.IsArray() {
		return 0
	}
	return int(res.Get("#").Value().(float64))
}

func (r Fruits) Set(v Fruits) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Fruits) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *Fruits) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Fruits{_json: &bcopy}
	return nil
}
func (r Fruits) json() []byte {
	if r._json == nil {
		return []byte("[]")
	}

	return *r._json
}
func (r Fruits) path() string {
	return r._path
}
func (r Fruits) setJson(v []byte) {
	*r._json = v
}
func (r *Fruits) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Fruits) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Fruits) Exists() bool {
	return r.result().Exists()
}
func (r Fruits) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Int64 struct {
	_path string
	_json *[]byte
}

func (r Int64) Value() int64 {
	res := r.result()
	var v int64
	_ = json.Unmarshal([]byte(res.Raw), &v)
	return v
}

func (r *Int64) Set(v int64) error {
	r.ensureJson()
	if r._path == "" {
		b, err := json.Marshal(v)
		if err != nil {
			return err
		}
		r.setJson(b)
		return nil
	}
	res, err := sjson.SetBytes(r.json(), r.path(), v)
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Int64) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *Int64) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Int64{_json: &bcopy}
	return nil
}
func (r Int64) json() []byte {
	if r._json == nil {
		return []byte("0")
	}

	return *r._json
}
func (r Int64) path() string {
	return r._path
}
func (r Int64) setJson(v []byte) {
	*r._json = v
}
func (r *Int64) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Int64) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Int64) Exists() bool {
	return r.result().Exists()
}
func (r Int64) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type OneOf struct {
	_path string
	_json *[]byte
}

func (r *OneOf) GetData() *OneOfData {
	r.ensureJson()
	return &OneOfData{
		_path: pathJoin(r._path, "data"),
		_json: r._json,
	}
}

func (r OneOf) Set(v OneOf) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r OneOf) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *OneOf) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = OneOf{_json: &bcopy}
	return nil
}
func (r OneOf) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r OneOf) path() string {
	return r._path
}
func (r OneOf) setJson(v []byte) {
	*r._json = v
}
func (r *OneOf) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r OneOf) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r OneOf) Exists() bool {
	return r.result().Exists()
}
func (r OneOf) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type OneOfData struct {
	_path string
	_json *[]byte
}

func (r *OneOfData) AsPerson() *Person {
	r.ensureJson()
	return &Person{
		_path: r._path,
		_json: r._json,
	}
}

func (r *OneOfData) AsVehicle() *Vehicle {
	r.ensureJson()
	return &Vehicle{
		_path: r._path,
		_json: r._json,
	}
}

func (r OneOfData) Set(v OneOfData) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r OneOfData) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *OneOfData) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = OneOfData{_json: &bcopy}
	return nil
}
func (r OneOfData) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r OneOfData) path() string {
	return r._path
}
func (r OneOfData) setJson(v []byte) {
	*r._json = v
}
func (r *OneOfData) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r OneOfData) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r OneOfData) Exists() bool {
	return r.result().Exists()
}
func (r OneOfData) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type OneOfOneOfRootObj struct {
	_path string
	_json *[]byte
}

func (r *OneOfOneOfRootObj) AsPerson() *Person {
	r.ensureJson()
	return &Person{
		_path: r._path,
		_json: r._json,
	}
}

func (r *OneOfOneOfRootObj) AsVehicle() *Vehicle {
	r.ensureJson()
	return &Vehicle{
		_path: r._path,
		_json: r._json,
	}
}

func (r OneOfOneOfRootObj) Set(v OneOfOneOfRootObj) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r OneOfOneOfRootObj) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *OneOfOneOfRootObj) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = OneOfOneOfRootObj{_json: &bcopy}
	return nil
}
func (r OneOfOneOfRootObj) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r OneOfOneOfRootObj) path() string {
	return r._path
}
func (r OneOfOneOfRootObj) setJson(v []byte) {
	*r._json = v
}
func (r *OneOfOneOfRootObj) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r OneOfOneOfRootObj) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r OneOfOneOfRootObj) Exists() bool {
	return r.result().Exists()
}
func (r OneOfOneOfRootObj) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Person struct {
	_path string
	_json *[]byte
}

func (r *Person) GetFirstName() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "firstName"),
		_json: r._json,
	}
}

func (r *Person) GetLastName() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "lastName"),
		_json: r._json,
	}
}

func (r *Person) GetSport() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "sport"),
		_json: r._json,
	}
}

func (r Person) Set(v Person) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Person) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *Person) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Person{_json: &bcopy}
	return nil
}
func (r Person) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r Person) path() string {
	return r._path
}
func (r Person) setJson(v []byte) {
	*r._json = v
}
func (r *Person) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Person) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Person) Exists() bool {
	return r.result().Exists()
}
func (r Person) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type ShippingAddress struct {
	_path string
	_json *[]byte
}

func (r *ShippingAddress) GetCity() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "city"),
		_json: r._json,
	}
}

func (r *ShippingAddress) GetType() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "type"),
		_json: r._json,
	}
}

func (r ShippingAddress) Set(v ShippingAddress) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r ShippingAddress) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *ShippingAddress) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = ShippingAddress{_json: &bcopy}
	return nil
}
func (r ShippingAddress) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r ShippingAddress) path() string {
	return r._path
}
func (r ShippingAddress) setJson(v []byte) {
	*r._json = v
}
func (r *ShippingAddress) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r ShippingAddress) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r ShippingAddress) Exists() bool {
	return r.result().Exists()
}
func (r ShippingAddress) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type String struct {
	_path string
	_json *[]byte
}

func (r String) Value() string {
	res := r.result()
	var v string
	_ = json.Unmarshal([]byte(res.Raw), &v)
	return v
}

func (r *String) Set(v string) error {
	r.ensureJson()
	if r._path == "" {
		b, err := json.Marshal(v)
		if err != nil {
			return err
		}
		r.setJson(b)
		return nil
	}
	res, err := sjson.SetBytes(r.json(), r.path(), v)
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r String) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *String) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = String{_json: &bcopy}
	return nil
}
func (r String) json() []byte {
	if r._json == nil {
		return []byte("\"\"")
	}

	return *r._json
}
func (r String) path() string {
	return r._path
}
func (r String) setJson(v []byte) {
	*r._json = v
}
func (r *String) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r String) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r String) Exists() bool {
	return r.result().Exists()
}
func (r String) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Vegetables struct {
	_path string
	_json *[]byte
}

func (r *Vegetables) At(i int) *Vegetables {
	r.ensureJson()
	return &Vegetables{
		_path: pathJoin(r._path, fmt.Sprint(i)),
		_json: r._json,
	}
}

func (r Vegetables) Len() int {
	res := r.result()
	if !res.IsArray() {
		return 0
	}
	return int(res.Get("#").Value().(float64))
}

func (r Vegetables) Set(v Vegetables) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Vegetables) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *Vegetables) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Vegetables{_json: &bcopy}
	return nil
}
func (r Vegetables) json() []byte {
	if r._json == nil {
		return []byte("[]")
	}

	return *r._json
}
func (r Vegetables) path() string {
	return r._path
}
func (r Vegetables) setJson(v []byte) {
	*r._json = v
}
func (r *Vegetables) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Vegetables) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Vegetables) Exists() bool {
	return r.result().Exists()
}
func (r Vegetables) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Vehicle struct {
	_path string
	_json *[]byte
}

func (r *Vehicle) GetBrand() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "brand"),
		_json: r._json,
	}
}

func (r *Vehicle) GetPrice() *Int64 {
	r.ensureJson()
	return &Int64{
		_path: pathJoin(r._path, "price"),
		_json: r._json,
	}
}

func (r Vehicle) Set(v Vehicle) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Vehicle) MarshalJSON() ([]byte, error) {
	return r.json(), nil
}
func (r *Vehicle) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Vehicle{_json: &bcopy}
	return nil
}
func (r Vehicle) json() []byte {
	if r._json == nil {
		return []byte("{}")
	}

	return *r._json
}
func (r Vehicle) path() string {
	return r._path
}
func (r Vehicle) setJson(v []byte) {
	*r._json = v
}
func (r *Vehicle) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Vehicle) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Vehicle) Exists() bool {
	return r.result().Exists()
}
func (r Vehicle) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}
