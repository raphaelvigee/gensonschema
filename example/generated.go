package gen

// Code generated by github.com/raphaelvigee/gensonschema. DO NOT EDIT!

import (
	"encoding/json"
	"fmt"

	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

func pathJoin(p1, p2 string) string {
	if p1 == "" {
		return p2
	}

	return p1 + "." + p2
}

type AllOf struct {
	_path string
	_json *[]byte
}

func (r *AllOf) GetBilling_address() *AllofDefinitionsAddress {
	r.ensureJson()
	return &AllofDefinitionsAddress{
		_path: pathJoin(r._path, "billing_address"),
		_json: r._json,
	}
}

func (r *AllOf) GetShipping_address() *AllofShipping_address {
	r.ensureJson()
	return &AllofShipping_address{
		_path: pathJoin(r._path, "shipping_address"),
		_json: r._json,
	}
}

func (r AllOf) Set(v AllOf) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllOf) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllOf) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllOf{_json: &bcopy}
	return nil
}
func (r AllOf) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllOf) path() string {
	return r._path
}
func (r AllOf) setJson(v []byte) {
	*r._json = v
}
func (r *AllOf) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllOf) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllOf) Exists() bool {
	return r.result().Exists()
}
func (r AllOf) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllOfOneOf struct {
	_path string
	_json *[]byte
}

func (r *AllOfOneOf) GetData() *AllofoneofData {
	r.ensureJson()
	return &AllofoneofData{
		_path: pathJoin(r._path, "data"),
		_json: r._json,
	}
}

func (r AllOfOneOf) Set(v AllOfOneOf) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllOfOneOf) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllOfOneOf) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllOfOneOf{_json: &bcopy}
	return nil
}
func (r AllOfOneOf) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllOfOneOf) path() string {
	return r._path
}
func (r AllOfOneOf) setJson(v []byte) {
	*r._json = v
}
func (r *AllOfOneOf) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllOfOneOf) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllOfOneOf) Exists() bool {
	return r.result().Exists()
}
func (r AllOfOneOf) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofDefinitionsAddress struct {
	_path string
	_json *[]byte
}

func (r *AllofDefinitionsAddress) GetCity() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "city"),
		_json: r._json,
	}
}

func (r AllofDefinitionsAddress) Set(v AllofDefinitionsAddress) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofDefinitionsAddress) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofDefinitionsAddress) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofDefinitionsAddress{_json: &bcopy}
	return nil
}
func (r AllofDefinitionsAddress) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofDefinitionsAddress) path() string {
	return r._path
}
func (r AllofDefinitionsAddress) setJson(v []byte) {
	*r._json = v
}
func (r *AllofDefinitionsAddress) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofDefinitionsAddress) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofDefinitionsAddress) Exists() bool {
	return r.result().Exists()
}
func (r AllofDefinitionsAddress) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofShipping_address struct {
	_path string
	_json *[]byte
}

func (r *AllofShipping_address) GetCity() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "city"),
		_json: r._json,
	}
}

func (r *AllofShipping_address) GetType() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "type"),
		_json: r._json,
	}
}

func (r AllofShipping_address) Set(v AllofShipping_address) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofShipping_address) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofShipping_address) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofShipping_address{_json: &bcopy}
	return nil
}
func (r AllofShipping_address) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofShipping_address) path() string {
	return r._path
}
func (r AllofShipping_address) setJson(v []byte) {
	*r._json = v
}
func (r *AllofShipping_address) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofShipping_address) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofShipping_address) Exists() bool {
	return r.result().Exists()
}
func (r AllofShipping_address) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofoneofData struct {
	_path string
	_json *[]byte
}

func (r *AllofoneofData) AsAllOf0OneOf0() *AllofoneofDataAllOf0OneOf0 {
	r.ensureJson()
	return &AllofoneofDataAllOf0OneOf0{
		_path: r._path,
		_json: r._json,
	}
}

func (r *AllofoneofData) AsAllOf0OneOf1() *AllofoneofDataAllOf0OneOf1 {
	r.ensureJson()
	return &AllofoneofDataAllOf0OneOf1{
		_path: r._path,
		_json: r._json,
	}
}

func (r *AllofoneofData) AsNamedOneOf0() *AllofoneofDataAllOf2OneOf0 {
	r.ensureJson()
	return &AllofoneofDataAllOf2OneOf0{
		_path: r._path,
		_json: r._json,
	}
}

func (r *AllofoneofData) AsNamedOneOf1() *AllofoneofDataAllOf2OneOf1 {
	r.ensureJson()
	return &AllofoneofDataAllOf2OneOf1{
		_path: r._path,
		_json: r._json,
	}
}

func (r *AllofoneofData) GetB() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "b"),
		_json: r._json,
	}
}

func (r AllofoneofData) Set(v AllofoneofData) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofoneofData) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofoneofData) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofoneofData{_json: &bcopy}
	return nil
}
func (r AllofoneofData) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofoneofData) path() string {
	return r._path
}
func (r AllofoneofData) setJson(v []byte) {
	*r._json = v
}
func (r *AllofoneofData) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofoneofData) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofoneofData) Exists() bool {
	return r.result().Exists()
}
func (r AllofoneofData) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofoneofDataAllOf0OneOf0 struct {
	_path string
	_json *[]byte
}

func (r *AllofoneofDataAllOf0OneOf0) GetA1() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "a1"),
		_json: r._json,
	}
}

func (r AllofoneofDataAllOf0OneOf0) Set(v AllofoneofDataAllOf0OneOf0) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofoneofDataAllOf0OneOf0) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofoneofDataAllOf0OneOf0) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofoneofDataAllOf0OneOf0{_json: &bcopy}
	return nil
}
func (r AllofoneofDataAllOf0OneOf0) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofoneofDataAllOf0OneOf0) path() string {
	return r._path
}
func (r AllofoneofDataAllOf0OneOf0) setJson(v []byte) {
	*r._json = v
}
func (r *AllofoneofDataAllOf0OneOf0) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofoneofDataAllOf0OneOf0) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofoneofDataAllOf0OneOf0) Exists() bool {
	return r.result().Exists()
}
func (r AllofoneofDataAllOf0OneOf0) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofoneofDataAllOf0OneOf1 struct {
	_path string
	_json *[]byte
}

func (r *AllofoneofDataAllOf0OneOf1) GetA2() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "a2"),
		_json: r._json,
	}
}

func (r AllofoneofDataAllOf0OneOf1) Set(v AllofoneofDataAllOf0OneOf1) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofoneofDataAllOf0OneOf1) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofoneofDataAllOf0OneOf1) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofoneofDataAllOf0OneOf1{_json: &bcopy}
	return nil
}
func (r AllofoneofDataAllOf0OneOf1) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofoneofDataAllOf0OneOf1) path() string {
	return r._path
}
func (r AllofoneofDataAllOf0OneOf1) setJson(v []byte) {
	*r._json = v
}
func (r *AllofoneofDataAllOf0OneOf1) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofoneofDataAllOf0OneOf1) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofoneofDataAllOf0OneOf1) Exists() bool {
	return r.result().Exists()
}
func (r AllofoneofDataAllOf0OneOf1) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofoneofDataAllOf2OneOf0 struct {
	_path string
	_json *[]byte
}

func (r *AllofoneofDataAllOf2OneOf0) GetC1() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "c1"),
		_json: r._json,
	}
}

func (r AllofoneofDataAllOf2OneOf0) Set(v AllofoneofDataAllOf2OneOf0) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofoneofDataAllOf2OneOf0) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofoneofDataAllOf2OneOf0) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofoneofDataAllOf2OneOf0{_json: &bcopy}
	return nil
}
func (r AllofoneofDataAllOf2OneOf0) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofoneofDataAllOf2OneOf0) path() string {
	return r._path
}
func (r AllofoneofDataAllOf2OneOf0) setJson(v []byte) {
	*r._json = v
}
func (r *AllofoneofDataAllOf2OneOf0) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofoneofDataAllOf2OneOf0) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofoneofDataAllOf2OneOf0) Exists() bool {
	return r.result().Exists()
}
func (r AllofoneofDataAllOf2OneOf0) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type AllofoneofDataAllOf2OneOf1 struct {
	_path string
	_json *[]byte
}

func (r *AllofoneofDataAllOf2OneOf1) GetC2() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "c2"),
		_json: r._json,
	}
}

func (r AllofoneofDataAllOf2OneOf1) Set(v AllofoneofDataAllOf2OneOf1) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r AllofoneofDataAllOf2OneOf1) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *AllofoneofDataAllOf2OneOf1) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = AllofoneofDataAllOf2OneOf1{_json: &bcopy}
	return nil
}
func (r AllofoneofDataAllOf2OneOf1) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r AllofoneofDataAllOf2OneOf1) path() string {
	return r._path
}
func (r AllofoneofDataAllOf2OneOf1) setJson(v []byte) {
	*r._json = v
}
func (r *AllofoneofDataAllOf2OneOf1) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r AllofoneofDataAllOf2OneOf1) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r AllofoneofDataAllOf2OneOf1) Exists() bool {
	return r.result().Exists()
}
func (r AllofoneofDataAllOf2OneOf1) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type ArraysSchemaArraysSchema struct {
	_path string
	_json *[]byte
}

func (r *ArraysSchemaArraysSchema) GetFruits() *ArraysSchemaFruits {
	r.ensureJson()
	return &ArraysSchemaFruits{
		_path: pathJoin(r._path, "fruits"),
		_json: r._json,
	}
}

func (r *ArraysSchemaArraysSchema) GetVegetables() *ArraysSchemaVegetables {
	r.ensureJson()
	return &ArraysSchemaVegetables{
		_path: pathJoin(r._path, "vegetables"),
		_json: r._json,
	}
}

func (r ArraysSchemaArraysSchema) Set(v ArraysSchemaArraysSchema) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r ArraysSchemaArraysSchema) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *ArraysSchemaArraysSchema) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = ArraysSchemaArraysSchema{_json: &bcopy}
	return nil
}
func (r ArraysSchemaArraysSchema) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r ArraysSchemaArraysSchema) path() string {
	return r._path
}
func (r ArraysSchemaArraysSchema) setJson(v []byte) {
	*r._json = v
}
func (r *ArraysSchemaArraysSchema) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r ArraysSchemaArraysSchema) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r ArraysSchemaArraysSchema) Exists() bool {
	return r.result().Exists()
}
func (r ArraysSchemaArraysSchema) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type ArraysSchemaFruits struct {
	_path string
	_json *[]byte
}

func (r *ArraysSchemaFruits) At(i int) *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, fmt.Sprint(i)),
		_json: r._json,
	}
}

func (r ArraysSchemaFruits) Len() int {
	res := r.result()
	if !res.IsArray() {
		return 0
	}
	return int(res.Get("#").Int())
}

func (r ArraysSchemaFruits) Set(v ArraysSchemaFruits) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r ArraysSchemaFruits) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *ArraysSchemaFruits) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = ArraysSchemaFruits{_json: &bcopy}
	return nil
}
func (r ArraysSchemaFruits) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r ArraysSchemaFruits) path() string {
	return r._path
}
func (r ArraysSchemaFruits) setJson(v []byte) {
	*r._json = v
}
func (r *ArraysSchemaFruits) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r ArraysSchemaFruits) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r ArraysSchemaFruits) Exists() bool {
	return r.result().Exists()
}
func (r ArraysSchemaFruits) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type ArraysSchemaVegetables struct {
	_path string
	_json *[]byte
}

func (r *ArraysSchemaVegetables) At(i int) *ArraysSchemaVegetables {
	r.ensureJson()
	return &ArraysSchemaVegetables{
		_path: pathJoin(r._path, fmt.Sprint(i)),
		_json: r._json,
	}
}

func (r ArraysSchemaVegetables) Len() int {
	res := r.result()
	if !res.IsArray() {
		return 0
	}
	return int(res.Get("#").Int())
}

func (r ArraysSchemaVegetables) Set(v ArraysSchemaVegetables) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r ArraysSchemaVegetables) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *ArraysSchemaVegetables) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = ArraysSchemaVegetables{_json: &bcopy}
	return nil
}
func (r ArraysSchemaVegetables) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r ArraysSchemaVegetables) path() string {
	return r._path
}
func (r ArraysSchemaVegetables) setJson(v []byte) {
	*r._json = v
}
func (r *ArraysSchemaVegetables) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r ArraysSchemaVegetables) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r ArraysSchemaVegetables) Exists() bool {
	return r.result().Exists()
}
func (r ArraysSchemaVegetables) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Bool struct {
	_path string
	_json *[]byte
}

func (r Bool) Value() bool {
	res := r.result()
	return res.Bool()
}
func (r *Bool) Set(v bool) error {
	r.ensureJson()
	if r._path == "" {
		b, err := json.Marshal(v)
		if err != nil {
			return err
		}
		r.setJson(b)
		return nil
	}
	res, err := sjson.SetBytes(r.json(), r.path(), v)
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Bool) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *Bool) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Bool{_json: &bcopy}
	return nil
}
func (r Bool) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r Bool) path() string {
	return r._path
}
func (r Bool) setJson(v []byte) {
	*r._json = v
}
func (r *Bool) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Bool) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Bool) Exists() bool {
	return r.result().Exists()
}
func (r Bool) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Int64 struct {
	_path string
	_json *[]byte
}

func (r Int64) Value() int64 {
	res := r.result()
	return res.Int()
}
func (r *Int64) Set(v int64) error {
	r.ensureJson()
	if r._path == "" {
		b, err := json.Marshal(v)
		if err != nil {
			return err
		}
		r.setJson(b)
		return nil
	}
	res, err := sjson.SetBytes(r.json(), r.path(), v)
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Int64) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *Int64) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Int64{_json: &bcopy}
	return nil
}
func (r Int64) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r Int64) path() string {
	return r._path
}
func (r Int64) setJson(v []byte) {
	*r._json = v
}
func (r *Int64) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Int64) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Int64) Exists() bool {
	return r.result().Exists()
}
func (r Int64) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type OneOf struct {
	_path string
	_json *[]byte
}

func (r *OneOf) GetData() *OneofData {
	r.ensureJson()
	return &OneofData{
		_path: pathJoin(r._path, "data"),
		_json: r._json,
	}
}

func (r OneOf) Set(v OneOf) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r OneOf) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *OneOf) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = OneOf{_json: &bcopy}
	return nil
}
func (r OneOf) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r OneOf) path() string {
	return r._path
}
func (r OneOf) setJson(v []byte) {
	*r._json = v
}
func (r *OneOf) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r OneOf) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r OneOf) Exists() bool {
	return r.result().Exists()
}
func (r OneOf) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type OneOfRootObj struct {
	_path string
	_json *[]byte
}

func (r *OneOfRootObj) AsPerson() *Person {
	r.ensureJson()
	return &Person{
		_path: r._path,
		_json: r._json,
	}
}

func (r *OneOfRootObj) AsVehicle() *Vehicle {
	r.ensureJson()
	return &Vehicle{
		_path: r._path,
		_json: r._json,
	}
}

func (r OneOfRootObj) Set(v OneOfRootObj) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r OneOfRootObj) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *OneOfRootObj) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = OneOfRootObj{_json: &bcopy}
	return nil
}
func (r OneOfRootObj) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r OneOfRootObj) path() string {
	return r._path
}
func (r OneOfRootObj) setJson(v []byte) {
	*r._json = v
}
func (r *OneOfRootObj) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r OneOfRootObj) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r OneOfRootObj) Exists() bool {
	return r.result().Exists()
}
func (r OneOfRootObj) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type OneofData struct {
	_path string
	_json *[]byte
}

func (r *OneofData) AsPerson() *Person {
	r.ensureJson()
	return &Person{
		_path: r._path,
		_json: r._json,
	}
}

func (r *OneofData) AsVehicle() *Vehicle {
	r.ensureJson()
	return &Vehicle{
		_path: r._path,
		_json: r._json,
	}
}

func (r OneofData) Set(v OneofData) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r OneofData) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *OneofData) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = OneofData{_json: &bcopy}
	return nil
}
func (r OneofData) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r OneofData) path() string {
	return r._path
}
func (r OneofData) setJson(v []byte) {
	*r._json = v
}
func (r *OneofData) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r OneofData) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r OneofData) Exists() bool {
	return r.result().Exists()
}
func (r OneofData) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Person struct {
	_path string
	_json *[]byte
}

func (r *Person) GetFirstName() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "firstName"),
		_json: r._json,
	}
}

func (r *Person) GetLastName() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "lastName"),
		_json: r._json,
	}
}

func (r *Person) GetSport() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "sport"),
		_json: r._json,
	}
}

func (r Person) Set(v Person) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Person) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *Person) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Person{_json: &bcopy}
	return nil
}
func (r Person) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r Person) path() string {
	return r._path
}
func (r Person) setJson(v []byte) {
	*r._json = v
}
func (r *Person) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Person) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Person) Exists() bool {
	return r.result().Exists()
}
func (r Person) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type String struct {
	_path string
	_json *[]byte
}

func (r String) Value() string {
	res := r.result()
	return res.String()
}
func (r *String) Set(v string) error {
	r.ensureJson()
	if r._path == "" {
		b, err := json.Marshal(v)
		if err != nil {
			return err
		}
		r.setJson(b)
		return nil
	}
	res, err := sjson.SetBytes(r.json(), r.path(), v)
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r String) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *String) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = String{_json: &bcopy}
	return nil
}
func (r String) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r String) path() string {
	return r._path
}
func (r String) setJson(v []byte) {
	*r._json = v
}
func (r *String) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r String) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r String) Exists() bool {
	return r.result().Exists()
}
func (r String) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

type Vehicle struct {
	_path string
	_json *[]byte
}

func (r *Vehicle) GetBrand() *String {
	r.ensureJson()
	return &String{
		_path: pathJoin(r._path, "brand"),
		_json: r._json,
	}
}

func (r *Vehicle) GetPrice() *Int64 {
	r.ensureJson()
	return &Int64{
		_path: pathJoin(r._path, "price"),
		_json: r._json,
	}
}

func (r Vehicle) Set(v Vehicle) error {
	if r._path == "" {
		r.setJson(v.json())
		return nil
	}
	res, err := sjson.SetRawBytes(r.json(), r.path(), v.json())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}

func (r Vehicle) MarshalJSON() ([]byte, error) {
	if r._path == "" {
		return r.json(), nil
	}

	res := r.result()
	return []byte(res.Raw), nil
}
func (r *Vehicle) UnmarshalJSON(b []byte) error {
	if r._json != nil {
		if r._path == "" {
			bcopy := make([]byte, len(b))
			copy(bcopy, b)

			r.setJson(bcopy)
			return nil
		}

		njson, err := sjson.SetRawBytes(r.json(), r.path(), b)
		if err != nil {
			return err
		}
		r.setJson(njson)
		return nil
	}

	bcopy := make([]byte, len(b))
	copy(bcopy, b)

	*r = Vehicle{_json: &bcopy}
	return nil
}
func (r Vehicle) json() []byte {
	if r._json == nil {
		return []byte("")
	}

	return *r._json
}
func (r Vehicle) path() string {
	return r._path
}
func (r Vehicle) setJson(v []byte) {
	*r._json = v
}
func (r *Vehicle) ensureJson() {
	if r._json != nil {
		return
	}

	b := r.json()
	r._json = &b
}
func (r Vehicle) result() gjson.Result {
	if r._path == "" {
		return gjson.ParseBytes(r.json())
	}
	return gjson.GetBytes(r.json(), r.path())
}
func (r Vehicle) Exists() bool {
	return r.result().Exists()
}
func (r Vehicle) Delete() error {
	res, err := sjson.DeleteBytes(r.json(), r.path())
	if err != nil {
		return err
	}
	r.setJson(res)
	return nil
}
